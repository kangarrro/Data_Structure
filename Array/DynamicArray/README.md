# 동적배열(Dynamic Array)

동적배열은 배열의 크기를 동적으로 변경할 수 있는 배열을 의미합니다.

---

## 1. 개념

-   기본 개녕
    C언어 등에서 지원하는 배열은 기본적으로 정적배열입니다. 정적배열은 크기를 변경할 수 없습니다(C의 realloc()을 이용할 수 있습니다).<br>
    이점을 보완하기 위해, 재할당 및 복사를 지원하는 동적배열을 사용합니다.
    기본적인 특성은 배열과 동일하지만, 재할당정책이 평균성능에 큰 영향을 미치므로, 상황에 따라 조절해야합니다.

-   재할당 정책에 따른 성능
    동적배열에서 재할당 정책은 동적배열 성능에 가장 중요한 요소 중 하나입니다.
    재할당은 일반적으로 매번 일어나는 것은 아니지만, 다른 연산에 비해 많은 자원이 필요합니다.
    기존의 점근표기법으로는 재할당을 포함한 성능을 올바르게 표현하기 어렵기 때문에, amortized time을 이용합니다.

    재할당의 가장 간단한 방법은 배열이 가득찰 때마다 상수 C만큼 할당해주는 것입니다.
    이 경우, `push_back()`을 반복하면, $1 + 2 + 3 + ... + m = (m^2+m)/2 = O(n^2)$ 만큼 복사해야합니다.

    배열을 2배씩 확장한다면, 어떨까요?
    이 방법은 Array Doubling이라고 불립니다. 이때는 $2^0+1, 2^1+1, 2^2+1$ 번째의 `push_back()`에서 $2^0+1, 2^1+1, 2^2+1$ 만큼의 복사가 이루어집니다. $2^0+1 + 2^1+1 + 2^2+1 + ... 2^k+1 = 2^(k+1) - 1$k는 배열의 최대 크기를 결정하는 지수로, 2^k \approx n일 때입니다. 따라서 복사 비용의 총합은 $O(n)$이 되고, Amortized Time은 $O(1)$이 됩니다.

---

## 2. 특징

-   앞서 설명한 배열의 특징을 모두 계승합니다.
-   재할당 정책에 따라 평균적인 성능이 달라집니다.

## 3. 시간복잡도

| 연산             | best | worst |
| ---------------- | ---- | ----- |
| 접근(Access)     | O(1) | O(1)  |
| 검색(Search)     | O(n) | O(n)  |
| 삽입(Insertion)  | O(1) | O(n)  |
| 삭제(Deletion)   | O(1) | O(n)  |
| 크기변경(resize) | O(n) | O(n)  |

---

## 4. 사용예제

```C++
#include <iostream>
#include "dynamic_array.h"

int main() {
    DynamicArray<int> arr(5, 0);

    arr.resize(10); // 10으로 크기변경

    for(int i = 0; i < arr.capacity(); i++)
        arr[i] = i; // arr = {0, 1, 2, 3, ... , 9}

    arr.push_back(11); // 마지막에 11 추가
    arr.push_back(12); // 마지막에 12 추가

    arr.pop_back(); // 마지막 요소(12) 삭제

    arr.insert(10, 10); // arr[10] = 10, 10 삽입
    arr.erase(arr.size() - 1); // 마지막 요소(11) 삭제

    // arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    return 0;
}

```

---

## 5. 기타

-   Python에서

-   C++ STL vector에서

-   Java에서
